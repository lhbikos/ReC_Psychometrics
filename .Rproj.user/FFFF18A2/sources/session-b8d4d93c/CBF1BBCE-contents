# Principal Axis Factoring {#PAF}

[Screencasted Lecture Link](https://youtube.com/playlist?list=PLtz5cFLQl4KMdUnDzMY2m-jm7-rAY9R0n&si=cJP-7pgYDhi_X459) 
 
```{r  include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA) #keeps out the hashtags in the knits
options(scipen=999)#eliminates scientific notation
```

This is the second lesson of *exploratory* principal components analysis (PCA) and factor analysis (EFA/PAF). This time the focus is on actual *factor analysis*. There are numerous approaches to this process (e.g., principal components analysis, parallel analyses). In this lesson I will demonstrate principal axis factoring (PAF).

## Navigating this Lesson

There is about an hour-and-a-half of lecture.  If you work through the materials with me it would be plan for an additional two hours.

While the majority of R objects and data you will need are created within the R script that sources the chapter, occasionally there are some that cannot be created from within the R framework. Additionally, sometimes links fail.  All original materials are provided at the [Github site](https://github.com/lhbikos/ReC_Psychometrics) that hosts the book. More detailed guidelines for ways to access all these materials are provided in the OER's [introduction](#ReCintro)

### Learning Objectives

Focusing on this lesson's materials, make sure you can:

* Distinguish between PCA and PAF on several levels:  
  + recognize PCA and PAF from a path diagram
  + define keywords associated with each:  factor loadings, linear components, describe v. explain.  
* Recognize/define an identity matrix -- what test would you use to diagnose it?
* Recognize/define multicollinearity and singularity -- what test would you use to diagnose it?
* Describe the desired pattern of "loadings" (i.e., the relative weights of an item on its own scale compared to other scales)
* Compare the results from item analysis, PCA, PAF, and omega.

### Planning for Practice

In each of these lessons I provide suggestions for practice that allow you to select one or more problems that are graded in difficulty. The least complex is to change the random seed in the research and rework the problem demonstrated in the lesson. The results *should* map onto the ones obtained in the lecture. 

The second option involves utilizing one of the simulated datasets available in this OER. The [last lesson](#sims) in the OER contains three simulations that could be used for all of the statistics-based practice suggestions. Especially if you started with one of these examples in an earlier lesson, I highly recommend you continue with that.

Alternatively, Keum et al.'s Gendered Racial Microaggressions Scale for Asian American Women [-@keum_gendered_2018] will be used in the lessons on confirmatory factor analysis and Conover et al.'s [-@conover_development_2017] Ableist Microaggressions Scale  is used in the lesson on invariance testing. Both of these would be suitable for the PCA and PAF homework assignments.

As a third option, you are welcome to use data to which you have access and is suitable for PCA. These could include other vignettes from this OER, other simualated data, or your own data (presuming you have permission to use it). In any case, please plan to:

* Properly format and prepare the data.
* Conduct diagnostic tests to determine the suitability of the data for PCA.
* Conducting tests to guide the decisions about number of factors to extract.
* Conducting orthogonal and oblique extractions (at least two each with different numbers of factors).
* Selecting one solution and preparing an APA style results section (with table and figure).
* Compare your results in light of any other psychometrics lessons where you have used this data (especially the [item analysis](#ItemAnalSurvey) and [PCA](#PCA) lessons).

### Readings & Resources

In preparing this chapter, I drew heavily from the following resource(s). Other resources are cited (when possible, linked) in the text with complete citations in the reference list.

* Revelle, William. (n.d.). Chapter 6: Constructs, components, and factor models. In *An introduction to psychometric theory with applications in R*. Retrieved from https://personality-project.org/r/book/#chapter6
  - pp. 150 to 167.  Stop at "Non-Simple Structure Solutions:  The Simplex and Circumplex."
  - A simultaneously theoretical review of psychometric theory while working with R and data to understand the concepts.
* Revelle, W. (2019). *How To: Use the psych package for Factor Analysis and data reduction*.
  - Treat as reference.  Pages 13 through 24 provide technical information about what we are doing.

### Packages

The packages used in this lesson are embedded in this code. When the hashtags are removed, the script below will (a) check to see if the following packages are installed on your computer and, if not (b) install them.
```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#will install the package if not already installed
#if(!require(psych)){install.packages("psych")}
#if(!require(tidyverse)){install.packages("tidyverse")}
#if(!require(MASS)){install.packages("MASS")}
#if(!require(sjstats)){install.packages("sjstats")}
#if(!require(apaTables)){install.packages("apaTables")}
#if(!require(qualtRics)){install.packages("qualtRics")}
```

## Exploratory Factor Analysis (with a quick contrast to PCA)

Whereas principal components analysis (PCA) is a regression analysis technique, principal factor analysis is a latent variable model [@revelle_william_chapter_nodate].

Exploratory factor analysis has a rich history.  In 1904, Spearman used it for a single factor.  In 1947, Thurstone generalized it to multiple factors.  Factor analysis is frequently used and controversial.

Factor analysis and principal components are commonly confused:

**Principal components** is

* linear sums of variables, 
* solved with an eigenvalue or singular decomposition,
* represented by an $n*n$ matrix in terms of the first *k* components and attempts to reproduce all of the $R$ matrix, and
* paths which point from the items to a total scale score -- all represented as observed/manifest (square) variables.

**Factor analysis** is

* linear sums of unknown factors,
* estimated as best fitting solutions, normally through iterative procedures, and
* controversial. Because:
  + At the *structural* level (i.e., covariance or correlation matrix), there are normally more observed variables than parameters to estimate them and the procedure seeks to find the best fitting solution using ordinary least squares, weighted least squares, or maximum likelihood.
  + At the *data* level, although scores can be estimated, the model is indeterminate.
  + This leads some to argue for using principal components; however fans of factor analysis suggest that it is useful for constructing and evaluating theories.
* an attempt to model only the *common* part of the matrix, which means all of the off-diagonal elements and the common part of the diagonal (the *communalities*); the *uniquenesses* are the non-common (leftover) part
  + Stated another way, the factor model partitions the correlation or covariance matrix into
    - *common factors*, $FF'$, and
    - that which is *unique*, $U^2$ (the diagonal matrix of *uniquenesses*)
* paths which point from the latent variable (LV) representing the factor (oval) to the items (squares) illustrating that the factor/LV "causes" the item's score

![Comparison of path models for PCA and EFA](images/PAF/PCAvPAF.png)

Our focus today is on the PAF approach to scale construction. By utilizing the same research vignette as in the [PCA lesson](#PCA), we can identify similarities in differences in the approach, results, and interpretation.  Let's first take a look at the workflow for PAF.

## PAF Workflow

Below is a screenshot of the workflow. The original document is located in the [Github site](https://github.com/lhbikos/ReC_Psychometrics) that hosts the ReCentering Psych Stats:  Psychometrics OER. You may find it refreshing that, with the exception of the change from "components" to "factors," the workflow for PCA and PAF are quite similar.

![Image of the workflow for PAF](images/PAF/PAFworkflow.png)

Steps in the process include:

* Creating an items only dataframe where all items are scaled in the same direction (i.e., negatively worded items are reverse-scored).
* Conducting tests that assess the statistical assumptions of PAF to ensure that the data is appropriate for PAF.
* Determining the number of factors (think "subscales") to extract. 
* Conducting the factor extraction -- this process will likely occur iteratively,
  - exploring orthogonal (uncorrelated/independent) and oblique (correlated) factors, and
  - changing the number of factors to extract

Because the intended audience for the ReCentering Psych Stats OER is the scientist-practitioner-advocate, this lesson focuses on the workflow and decisions. As you might guess, the details of PAF can be quite complex. Some important notions to consider that may not be obvious from lesson, are these:

* The values of factor loadings are directly related to the correlation matrix.
  - Although I do not explain this in detail, nearly every analytic step attempts to convey this notion by presenting equivalent analytic options using the raw data and correlation matrix.
* PAF (like PCA and related EFA procecures) is about *dimension reduction* -- our goal is fewer factors (think subscales) than there are items.
  - In this lesson's vignette there are 25 items on the scale and we will have 4 subscales.
* As a latent variable procedure, PAF is both *exploratory* and *factor analysis.*  This is in contrast to our prior [PCA lesson](#PCA). Recall that PCA is a regression-based model and therefore not "factor analysis."
* Matrix algebra (e.g., using the transpose of a matrix, multiplying matrices together) plays a critical role in the analytic solution.

## Research Vignette

This lesson's research vignette emerges from Lewis and Neville's Gendered Racial Microaggressions Scale for Black Women [-@lewis_construction_2015]. The article reports on two separate studies that comprised the development, refinement, and psychometric evaluation of two parallel versions (stress appraisal, frequency) of the scale. Below, I simulate data from the final construction of the stress appraisal version as the basis of the lecture. Items were on a 6-point Likert scale ranging from 0 (*not at all stressful*) to 5 (*extremely stressful*).

Lewis and Neville [-@lewis_construction_2015] reported support for a total scale score (25 items) and four subscales.  Below, I list the four subscales along with the items and their abbreviation. At the outset, let me provide a content advisory. For those who hold this particular identity (or related identities) the content in the items may be upsetting. In other lessons, I often provide a variable name that gives an indication of the primary content of the item. In the case of the GRMS, I will simply provide an abbreviation of the subscale name and its respective item number. This will allow us to easily inspect the alignment of the item with its intended factor, and hopefully minimize discomfort. 

If you are not a member of this particular identity, I encourage you to learn about these microaggressions by reading the article in its entirety. Please do not ask members of this group to explain why these microaggressions are harmful or ask if they have encountered them.  The four factors, number of items, and sample item are as follows:

* Assumptions of Beauty and Sexual Objectification (10 items)
  - Unattractive because of size of butt (Obj1)
  - Negative comments about size of facial features (Obj2)
  - Imitated the way they think Black women speak (Obj3)
  - Someone made me feel unattractive (Obj4)
  - Negative comment about skin tone (Obj5)
  - Someone assumed I speak a certain way (Obj6)
  - Objectified me based on physical features(Obj7)
  - Someone assumed I have a certain body type (Obj8; stress only)
  - Made a sexually inappropriate comment (Obj9)
  - Negative comments about my hair when natural (Obj10)
  - Assumed I was sexually promiscuous (frequency only; not used in this simulation)
* Silenced and Marginalized (7 items)
  - I have felt unheard (Marg1)
  - My comments have been ignored (Marg2)
  - Someone challenged my authority (Marg3)
  - I have been disrespected in workplace (Marg4)
  - Someone has tried to “put me in my place” (Marg5)
  - Felt excluded from networking opportunities (Marg6)
  - Assumed I did not have much to contribute to the conversation (Marg7)
* Strong Black Woman Stereotype (5 items)
  - Someone assumed I was sassy and straightforward (Str1; stress only)
  - I have been told that I am too independent (Str2)
  - Someone made me feel exotic as a Black woman (Str2; stress only)
  - I have been told that I am too assertive
  - Assumed to be a strong Black woman
* Angry Black Woman Stereotype (3 items)
  - Someone has told me to calm down (Ang1)
  - Perceived to be “angry Black woman" (Ang2)
  - Someone accused me of being angry when speaking calm (Ang3)

Three additional scales were reported in the Lewis and Neville article [-@lewis_construction_2015]. 
Because (a) the focus of this lesson is on exploratory factor analytic approaches and, therefore, only requires item-level data for the scale, and (b) the article does not include correlations between the subscales/scales of all involved measures, I only simulated item-level data for the GRMS items.

Below, I walk through the data simulation. This is not an essential portion of the lesson, but I will lecture it in case you are interested. None of the items are negatively worded (relative to the other items), so there is no need to reverse-score any items.

Simulating the data involved using factor loadings, means, standard deviations, and correlations between the scales. Because the simulation will produce "out-of-bounds" values, the code below rescales the scores into the range of the Likert-type scaling and rounds them to whole values.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70), warning=FALSE, message=FALSE}
#Entering the intercorrelations means and standard deviations from the journal article

LewisGRMS_generating_model <- '
        #measurement model
        Objectification =~ .69*Obj1 + .69*Obj2 + .60*Obj3 + .59*Obj4 + .55*Obj5 + .55*Obj6 + .54*Obj7 + .50*Obj8 + .41*Obj9 + .41*Obj10
        Marginalized =~ .93*Marg1 + .81*Marg2 +.69*Marg3 + .67*Marg4 + .61*Marg5 + .58*Marg6 +.54*Marg7
        Strong =~ .59*Str1 + .55*Str2 + .54*Str3 + .54*Str4 + .51*Str5
        Angry =~ .70*Ang1 + .69*Ang2 + .68*Ang3
        
        #Means
         Objectification ~ 1.85*1
         Marginalized ~ 2.67*1
         Strong ~ 1.61*1
         Angry ~ 2.29*1
         
        #Correlations
         Objectification ~~ .63*Marginalized
         Objectification ~~ .66*Strong
         Objectification ~~ .51*Angry
         
         Marginalized ~~ .59*Strong
         Marginalized ~~ .62*Angry

         Strong ~~ .61*Angry
 
        '

set.seed(240311)
dfGRMS <- lavaan::simulateData(model = LewisGRMS_generating_model,
                              model.type = "sem",
                              meanstructure = T,
                              sample.nobs=259,
                              standardized=FALSE)

#used to retrieve column indices used in the rescaling script below
col_index <- as.data.frame(colnames(dfGRMS))

#The code below loops through each column of the dataframe and assigns the scaling accordingly
#Rows 1 thru 26 are the GRMS items

for(i in 1:ncol(dfGRMS)){  
  if(i >= 1 & i <= 25){   
    dfGRMS[,i] <- scales::rescale(dfGRMS[,i], c(0, 5))
  }
}

#rounding to integers so that the data resembles that which was collected
library(tidyverse)
dfGRMS <- dfGRMS %>% round(0) 

#quick check
#psych::describe(dfGRMS) 

```

The optional script below will let you save the simulated data to your computing environment as either an .rds object (preserves any formatting you might do) or a .csv file (think "Excel lite"). 

An .rds file preserves all formatting to variables prior to the export and re-import.  For the purpose of this chapter, you don't need to do either. That is, you can re-simulate the data each time you work the problem.
```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#to save the df as an .rds (think "R object") file on your computer; it should save in the same file as the .rmd file you are working with
#saveRDS(dfGRMS, "dfGRMS.rds")
#bring back the simulated dat from an .rds file
#dfGRMS <- readRDS("dfGRMS.rds")
```

If you save the .csv file and bring it back in, you will lose any formatting (e.g., ordered factors will be interpreted as character variables).
```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#write the simulated data  as a .csv
#write.table(dfGRMS, file="dfGRMS.csv", sep=",", col.names=TRUE, row.names=FALSE)
#bring back the simulated dat from a .csv file
#dfGRMS <- read.csv ("dfGRMS.csv", header = TRUE)
```

Before moving on, I want to acknowledge that (at their first drafting), I try to select research vignettes that have been published within the prior 5 years. With a publication date of 2015, this article clearly falls outside that range. I have continued to include it because (a) the scholarship is superior -- especially as the measure captures an intersectional identity, (b) the article has been a model for research that follows (e.g., Keum et al's [-@keum_gendered_2018] Gendered Racial Microaggression Scale for Asian American Women), and (c) there is often a time lag between the initial publication of a psychometric scale and it's use. A key reason I have retained the GRMS as a psychometrics research vignette is that in [ReCentering Psych Stats: Multivariate Modeling](https://lhbikos.github.io/ReC_MultivModel/), GRMS scales are used in a couple of more recently published research vignettes.

## Working the Vignette

It may be useful to recall how we might understand factors in the psychometric sense:  

* clusters of correlated items in an $R$-matrix
* statistical entities that can be plotted as classification axes where coordinates of variables along each axis represen the strength of the relationship between that variable to each factor.
* mathematical equations, resembling regression equations, where each variable is represented according to its relative weight

### Data Prep      

Since the first step is data preparation, let's start by:

* reverse coding any items that are phrased in the opposite direction 
* creating a *df* (as an object) that only contains the items in their properly scored direction (i.e., you might need to replace the original item with the reverse-coded item); there should be no other variables (e.g., ID, demographic variables, other scales) in this df
  - because the GRMS has no items like this we can skip these two steps

Our example today requires no reverse coding and the dataset I simulated only has item-level data (with no ID and no other variables). This means we are ready to start the PAF process.

Let's take a look at (and make an object of) the correlation matrix.  

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
GRMSr <- cor(dfGRMS) #correlation matrix (with the negatively scored item already reversed) created and saved as object
round(GRMSr, 2)
```

In case you want to examine it in sections (easier to view):

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#round(GRMSr[,1:8], 2)
#round(GRMSr[,9:16], 2)
#round(GRMSr[,17:25], 2)
```

As with PCA, we can analyze the data with either raw data or correlation matrix.  I will do both to demonstrate (a) that it's possible and to (b) continue emphasizing that this is a *structural* analysis.  That is, we are trying to see if our more parsimonious extraction *reproduces* this original correlation matrix.

#### Three Diagnostic Tests to Evaluate the Appropriateness of the Data for Factor (or Component))Analysis  

Here's a snip of our location in the PAF workflow.

![Image of our location in the PAF workflow ](images/PAF/PAS_assumptions.png)

##### Is my sample adequate for PAF?      

We return to the **KMO** (Kaiser-Meyer-Olkin), an index of *sampling adequacy* that can  be used with the actual sample to let us know if the sample size is sufficient (or if we should collect more data).

Kaiser's 1974 recommendations were:

* bare minimum of .5
* values between .5 and .7 are mediocre
* values between .7 and .8 are good
* values above .9 are superb

We use the *KMO()* function from the *psych* package with either raw or matrix dat.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
psych::KMO(dfGRMS)
#psych::KMO(GRMSr) #for the KMO function, do not specify sample size if using the matrix form of the data
```

We examine the KMO values for both the overall matrix and the individual items.

At the matrix level, our $KMO = .85$, which falls in between Kaiser's definitions of *good* and *superb*.  

At the item level, the KMO should be > .50.  Variables with values below .5 should be evaluated for exclusion from the analysis (or run the analysis with and without the variable and compare the difference).  Because removing/adding variables impacts the KMO, be sure to re-evaluate.

At the item level, our KMO values range between .74 (Str4) and .91 (Obj2). 

Considering both item- and matrix- levels, we conclude that the sample size and the data are adequate for factor (or component) analysis.

##### Are the correlations among the variables big enough to be analyzed?      

**Bartlett's** lets us know if a matrix is an *identity matrix.* In an identity matrix all correlation coefficients (everything on the off-diagonal) would be 0.0 (and everything on the diagonal would be 1.0).  

A significant Barlett's (i.e., $p < .05$) tells that the $R$-matrix is not an identity matrix.  That is, there are some relationships between variables that can be analyzed.

The *cortest.bartlett()* function in the *psych* package and can be run either from the raw data or R matrix formats.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
psych::cortest.bartlett(dfGRMS) #from the raw data
#raw data produces the warning "R was not square, finding R from data." This means nothing other than we fed it raw data and the function is creating a matrix from which to do the analysis.

#psych::cortest.bartlett(GRMSr, n = 259) #if using the matrix, must specify sample size
```

Our Bartlett's test is significant:  $\chi^{2}(300)=1217.508, p < .001$. This supports a factor (or component) analytic approach for investigating the data.

##### Is there multicollinearity or singularity in my data?      

The **determinant of the correlation matrix** should be greater than 0.00001 (that would be 4 zeros before the 1).  If it is smaller than 0.00001 then we may have an issue with *multicollinearity* (i.e., variables that are too highly correlated) or *singularity* (variables that are perfectly correlated).

The determinant function comes from base R.  It is easiest to compute when the correlation matrix is the object.  However, it is also possible to specify the command to work with the raw data.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#det(GRMSr) 
det(cor(dfGRMS))#if using the raw data
```

With a value of 0.0075, our determinant is greater than the 0.00001 requirement.  If it were not, then we could identify problematic variables (i.e., those correlating too highly with others and those not correlating sufficiently with others) and re-run the diagnostic statistics.

#### APA Style Summary So Far

>Data screening were conducted to determine the suitability of the data for this analyses. The Kaiser-Meyer-Olkin measure of sampling adequacy (KMO; Kaiser, 1970) represents the ratio of the squared correlation between variables to the squared partial correlation between variables. KMO ranges from 0.00 to 1.00; values closer to 1.00 indicate that the patterns of correlations are relatively compact and that factor analysis should yield distinct and reliable factors (Field, 2012). In our dataset, the KMO value was .85, indicating acceptable sampling adequacy. The Barlett’s Test of Sphericity examines whether the population correlation matrix resembles an identity matrix (Field, 2012). When the *p* value for the Bartlett’s test is < .05, we are fairly certain we have clusters of correlated variables. In our dataset, $\chi^{2}(300)=1217.508, p < .001$, indicating the correlations between items are sufficiently large enough for principal axis factoring.  The determinant of the correlation matrix alerts us to any issues of multicollinearity or singularity and should be larger than 0.00001. Our determinant was 0.0075, supporting the suitability of our data for analysis.

*Note*:  If this looks familiar,  it is!  The same diagnostics are used in PAF and [PCA](#PCA).

### Principal Axis Factoring (PAF)   

Here's a snip of our location in the PAF workflow.

![Image of our location in the PAF workflow ](images/PAF/PAF_ExtractionNo.png)

We can use the *fa()* function, specifying *fm = "pa"* from the *psych* package with raw or matrix data.

One difference from PCA is that factor analysis will not (cannot) calculate as many factors as there are items.  This means that we should select a reasonable number, like 20 (since there are 25 items).  However, I received a number of errors/warnings and 13 is the first number that would run. I also received the warning, "maximum iteration exceeded."  Therefore I increased "max.iter" to 100.

Our goal is to begin to get an idea of the cumulative variance explained and number of factors to extract. If we think there are four factors, we simply need to specify more than four factors on the *nfactors = ##* command. As long as that number is less than the total number of items, it does not matter what that number is.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70), message = FALSE}
#grmsPAF1 <- psych::fa(GRMSr, nfactors=10, fm = "pa", max.iter = 100, rotate="none")# using the matrix data and specifying the # of factors.

grmsPAF1 <- psych::fa(dfGRMS, nfactors = 13, fm = "pa", max.iter = 100, rotate = "none")# using raw data and specifying the max number of factors

#I received the warning "maximum iteration exceeded". It gave output, but it's best if we don't get that warning, so I increased it to 100. 

grmsPAF1 #this object holds a great deal of information 
```
The total variance for a particular variable will have two factors: some variance will be shared with other variables (common variance) and some variance will be specific to that measure (unique variance).  Random variance is also specific to one item, but not reliably so. We can examine this most easily by examining the matrix (second screen). 

The columns PA1 thru PA10 are the (uninteresting at this point) unrotated loadings.  These are the loading from each factor to each variable. PA stands for "principal axis."

Scrolling to the far right we are interested in:

**Communalities** are represented as $h^2$. These are the proportions of common variance present in the variables.  A variable that has no specific (or random) variance would have a communality of 1.0.  If a variable shares none of its variance with any other variable, its communality would be 0.0. As a point of comparison, in PCA these started as 1.0 because we extracted the same number of components as items. In PAF, because we must extract fewer factors than items, these will have unique values.

**Uniquenesses* are represented as $u2$.  These are the amount of unique variance for each variable.  They are calculated as $1 - h^2$ (or 1 minus the communality).  

The final column, *com* represents *item complexity.*  This is an indication of how well an item reflects a single construct. If it is 1.0 then the item loads only on one factor, if it is 2.0, it loads evenly on two factors, and so forth. For now, we can ignore this. *I mostly wanted to reassure you that "com" is not "communality" -- h2 is communality*.

Let's switch to the first screen of output.

**Eigenvalues** are displayed in the row called, *SS loadings* (i.e., the sum of squared loadings).  They represent the variance explained by the particular linear factor. PA1 explains 4.86 units of variance (out of a possible 25; the # of potential factors).  As a proportion, this is 4.86/25 = 0.1944 (reported in the *Proportion Var* row).  We inspect the eigenvalues to see how many are > 1.0 (Kaiser's eigenvalue > 1 criteria criteria).  We see there are three that meet Kaiser's critera and four that meet Joliffe's criteria (eigenvalues > .70).

```{r}
4.86/25
```
**Cumulative Var** is helpful to determine how many factors we'd like to retain to balance parsimony (few as possible) with the amount of variance we want to explain. Directly related to the eigenvalues, we can see how including each additional factor accounts for a greater proportion of variance. 

**Scree plots** can help us visualize the relationship between the eigenvalues. A rule of thumb is to select the number of factors that is associated with the number of dots before the flattening of the curve. Eigenvalues are stored in the *grmsPAF1* object's variable, "values".  We can see all the values captured by this object with the *names()* function:

```{r}
names(grmsPAF1)
```

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
plot(grmsPAF1$values, type = "b") #type = "b" gives us "both" lines and points;  type = "l" gives lines and is relatively worthless
```

We look for the point of *inflexion*.  That is, where the baseline levels out into a plateau. I can see inflections after 1, 2, 3, and 4.

#### Specifying the number of factors      

Here's a snip of our location in the PAF workflow.

![Image of our location in the PAF workflow ](images/PAF/PAF_extraction.png)

Having determined the number of factors, we must rerun the analysis with this specification. Especially when researchers may not have a clear theoretical structure that guides the process, researchers may do this iteratively with varying numbers of factors. Lewis and Neville [@lewis_construction_2015] examined solutions with 2, 3, 4, and 5 factors (they conducted a parallel *factor* analysis; in contrast this lesson demonstrates principal axis factoring).

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#grmsPAF2 <- psych::fa(GRMSr, nfactors=4, fm = "pa", rotate="none")
grmsPAF2 <- psych::fa(dfGRMS, nfactors = 4, fm = "pa", rotate = "none") #can copy prior script, but change nfactors and object name
grmsPAF2
```

Our eigenvalues/SS loadings wiggle around a bit from the initial run. With four factors, we now, cumulatively, explain 28% of the variance.  

*Communality* is the proportion of common variance within a variable.  Changing from 13 to 4 factors changed these values ($h2$) as well as their associated *uniquenesses* ($u2$), which are calculated as "1.0 minus the communality." 

Now we see that 29% of the variance associated with Obj1 is common/shared (the $h2$ value).

As a reminder of what we are doing, recall that we are looking for a more *parsimonious* explanation than 25 items on the GRMS. By respecifying a smaller number of factors, we lose some information.  That is, the retained factors (now 4) cannot explain all of the variance present in the data (as we saw, it explains about 28%, cumulatively). The amount of variance explained in each variable is represented by the communalities after extraction.

We can also inspect the communalities through the lens of Kaiser's criterion (the eigenvalue > 1 criteria) to see if we think that four was a good number of factors to extract.

Kaiser's criterion is believed to be accurate:

* when there are fewer than 30 variables (we had 25) and, after extraction, the communalities are greater than .70
  + looking at our data, none of the communalities is > .70, so, this does not support extracting four factors
* When the sample size is greater than 250 (ours was 259) and the average communality is > .60
  + calculated below, ours was .28.

Using the *names()* function again, we see that "communality" is available for manipulation. 
```{r}
names(grmsPAF2)
```

We can use this value to calculate their mean.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
mean(grmsPAF2$communality)
#sum(grmsPAF2$communality) #
```

We see that our average communality is 0.28. These two criteria suggest that we may not have the best solution. That said (in our defense):

*  We used the scree plot as a guide and it was very clear.
*  We have an adequate sample size and that was supported with the KMO.
*  Are the number of factors consistent with theory?  We have not yet inspected the factor loadings. This will provide us with more information.

We could do several things:

* rerun with a different number of factors (recall Lewis and Neville [-@lewis_construction_2015] ran models with 2, 3, 4, and 5 factors)
* conduct more diagnostics tests
  + reproduced correlation matrix
  + the difference between the reproduced correlation matrix and the correlation matrix from the data
  
The *factor.model()* function in *psych* produces the *reproduced correlation matrix* by using the *loadings* in our extracted object.  Conceptually, this matrix is the correlations that should be produced if we did not have the raw data but we only had the factor loadings.  

The questions, though, is:  How close did we get?  How different is the *reproduced correlation matrix* from *GRMSmatrix* -- the $R$-matrix produced from our raw data.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
round(psych::factor.model(grmsPAF2$loadings), 3)#produces the reproduced correlation matrix
```

We're not really interested in this matrix. We just need it to compare it to the *GRMSmatrix* to produce the residuals.  We do that next.

**Residuals** are the difference between the reproduced (i.e., those created from our factor loadings) and $R$-matrix produced by the raw data.  

If we look at the $r_{_{Obj1Obj2}}$ in our original correlation matrix (theoretically from the raw data [although we simulated data]), the value is 0.35.  The reproduced correlation for this pair is 0.304.  The difference is 0.046.  The residuals table below shows 0.051 (rounding error).

```{r}
.35 - .304
```

By using the *factor.residuals()* function we can calculate the residuals.  Here we will see this difference calculated for us, for all the elements in the matrix.
```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
round(psych::factor.residuals(GRMSr, grmsPAF2$loadings), 3)
```

There are several strategies to evaluate this matrix.

* Compare the size of the residuals to the original correlations. 
  + The worst possible model would occur if we extracted no factors and the residuals are the size of the original correlations.
  + If the correlations were small to start with, we expect small residuals.
  + If the correlations were large to start with, the residuals will be relatively larger (this is not terribly problematic).
* Comparing residuals requires squaring them first (because residuals can be both positive and negative)
  + The sum of the squared residuals divided by the sum of the squared correlations is an estimate of model fit.  
    - Subtracting this from 1.0 means that it ranges from 0 to 1.  
    - Values > .95 are an indication of good fit.

Analyzing the residuals means we need to extract only the upper right of the triangle them into an object. We can do this in steps.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
grmsPAF2_resids <- psych::factor.residuals(GRMSr, grmsPAF2$loadings)#first extract the resids
grmsPAF2_resids <- as.matrix(grmsPAF2_resids[upper.tri(grmsPAF2_resids)])#the object has the residuals in a single column
head(grmsPAF2_resids)
#unhashtag for a view of all the residuals
#grmsPAF2_resids 
```

One criteria of residual analysis is to see how many residuals there are that are greater than an absolute value of 0.05. The result will be a single column with TRUE if it is > |0.05| and false if it is smaller. The sum function will tell us how many TRUE responses are in the matrix.  Further, we can write script to obtain the proportion of total number of residuals. 

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
large.resid <- abs(grmsPAF2_resids) > 0.05
#large.resid
sum(large.resid)
round(sum(large.resid) / nrow(grmsPAF2_resids),3)
```

We learn that there are 57 residuals greater than the absolute value of 0.05.  This represents 19% of the total number of residuals.

There are no hard rules about what proportion of residuals can be greater than 0.05. Field recommends that it stay below 50% [@field_discovering_2012].

Another approach to analyzing residuals is to look at their mean.  Because of the +/- valences, we need to square them (to eliminate the negative), take the average, then take the square root.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
round(sqrt(mean(grmsPAF2_resids^2)), 3)
```

While there are no clear guidelines to interpret these, one recommendation is to consider extracting more factors if the value is higher than 0.08 [@field_discovering_2012]. 

Finally, we expect our residuals to be normally distributed.  A histogram can help us inspect the distribution.

```{r }
hist(grmsPAF2_resids)
```

Not bad!  It looks reasonably normal.  No outliers.

####  Quick recap of how to evaluate the # of factors we extracted      

* If fewer than 30 variables, the eigenvalue > 1 (Kaiser's) critera is fine, so long as communalities are all > .70.
* If sample size > 250 and the average communalities are .6 or greater, this is acceptable
* When *N* > 200, the scree plot can be used.
* Regarding residuals:
  + Fewer than 50% should have absolute values > 0.05.
  + Model fit should be > 0.90.
  
### Factor Rotation

Here's a snip of our location in the PAF workflow.

![Image of our location in the PAF workflow ](images/PAF/PAF_rotation.png)

The original solution of a principal components or principal axis factor analysis is a set of vectors that best account for the observed covariance or correlation matrix.  Each additional component or factor accounts for progressively less and less variance.  The solution is efficient (yay) but difficult to interpret (boo).

Thanks to Thurstone's five rules toward a simple structure (circa 1947), interpretation of a matrix is facilitaed by *rotation* (multiplying a matrix by a matrix of orthogonal vectors that preserve the communalities of each variable). Both the original matrix and the solution will be orthogonal. 

*Parsimony* becomes a statistical consideration (an equation, in fact) and goal and is maximized when each variable has a 1.0 loading on one factor and the rest are zero.

Different rotation strategies emphasize different goals related to parsimony:

*Quartimax* seeks to maximize the notion of variable parsimony (each variable is associated with one factor) and permits the rotation toward a general factor (ignoring smaller factors).
*Varimax* maximizes the variance of squared loadings taken over items instead of over factors and *avoids* a general factor.

Rotation improves the interpretation of the factor by maximizing the loading on each variable on one of the extracted factors while minimizing the loading on all other factors.  Rotation works by changing the absolute values of the variables while keeping their differential values constant.

There are two big choices (to be made on theoretical grounds):

* Orthogonal rotation if you think that the factors are independent/unrelated.
  + varimax is the most common orthogonal rotation
* Oblique rotation if you think that the factors are related/correlated.
  + oblimin and promax are common oblique rotations

#### Orthogonal rotation

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#grmsPAF2ORTH <- psych::fa(GRMSr, nfactors = 4, fm = "pa", rotate = "varimax")
grmsPAF2ORTH <- psych::fa(dfGRMS, nfactors = 4, fm = "pa", rotate = "varimax")
grmsPAF2ORTH
```

Essentially, we have the same information as before, except that loadings are calculated after rotation (which adjusts the absolute values of the factor loadings while keeping their differential vales constant).  Our communality and uniqueness values remain the same. The eigenvalues (SS loadings) should even out, but the proportion of variance explained and cumulative variance (28%) will remain the same.
  
The *print.psych()* function facilitates interpretation and prioritizes the information about which we care most:

* *cut* displays loadings above .3, this allows us to see
  - if some items load on no factors
  - if some items have cross-loadings (and their relative weights)
* *sort* reorders the loadings to make it clearer (considering ties, to the best of its ability) to which factor/scale it belongs

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
grmsPAF2_table <- psych::print.psych(grmsPAF2ORTH, cut = 0.3, sort = TRUE)
```

In the unrotated solution, most variables loaded on the first factor. After rotation, there are four clear factors/scales.  Further, there is clear (or at least reasonable) factor/scale membership for each item and few cross-loadings. As with the PAC in the previous lesson, Ang1 is not clearly loading on the Angry scale.

If this were a new scale and we had not yet established ideas for subscales, the next step would be to look back at the items, themselves, and try to name the scales/factors. If our scale construction included a priori/planned subscales, we would hope the items would where they were hypothesized to do so. As we noted with the Ang1 item, our simulated data nearly replicated the item membership onto the four scales that Lewis and Neville [@lewis_construction_2015] reported in the article.

* Assumptions of Beauty and Sexual Objectification
* Silenced and Marginalized
* Strong Woman Stereotype
* Angry Woman Stereotype

We can also create a figure of the result. Note the direction of the arrows from the factor (latent variable) to the items in PAF -- in PCA the arrows went from item to component.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
psych::fa.diagram(grmsPAF2ORTH)
```

We can extract the factor loadings and write them to a table. This can be useful in preparing an APA style table for a manuscript or presentation.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#names(grmsPAF2ORTH)
pafORTH_table <- round(grmsPAF2ORTH$loadings,3)
write.table(pafORTH_table, file="pafORTH_table.csv", sep=",", col.names=TRUE, row.names=FALSE)
pafORTH_table
```

#### Oblique rotation

Whereas the orthogonal rotation sought to maximize the independence/unrelatedness of the factors, an oblique rotation will allow them to be correlated. Researchers often explore both solutions but only report one.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#grmsPAF2obl <- psych::fa(GRMSr, nfactors = 4, fm = "pa", rotate = "oblimin")
grmsPAF2obl <- psych::fa(dfGRMS, nfactors = 4, fm = "pa", rotate = "oblimin")
grmsPAF2obl
```

We can make it a little easier to interpret by removing all factor loadings below .30.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
psych::print.psych(grmsPAF2obl, cut = 0.3, sort=TRUE)
```
In this rotation, the Angry scale falls apart. As before, Ang1 is loading onto Strong. Additionally Ang3 has factor loadings that fall below .30, and therefore do not appear in this table. Additionally, because our specification included "sort=TRUE", the relative weights wiggled around and so the items are listed in a different order than in the orthogonal rotation.

The oblique rotation allows us to see the correlation between the factors/scales.  This was not available in the orthogonal rotation because the assumption of the orthogonal/varimax rotation is that the scales/factors are uncorrelated; hence in the analysis they were fixed to 0.0. The correlations from our simulated data range from .19 to .46.

Of course there is always a little complexity.  In oblique rotations, there is a distinction between the *pattern* matrix (which reports factor loadings and is comparable to the matrix we interpreted for the orthogonal rotation) and the *structure* matrix (takes into account the relationship between the factors/scales -- it is a product of the pattern matrix and the matrix containing the correlation coefficients between the factors/scales).  Most interpret the pattern matrix because it is simpler; however it could be that values in the pattern matrix are suppressed because of relations between the factors.  Therefore, the structure matrix can be a useful check and some editors will request it.

Obtaining the structure matrix requires two steps. First, multiply the factor loadings with the phi matrix.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
grmsPAF2obl$loadings %*% grmsPAF2obl$Phi
```

Next, use Field's [-@field_discovering_2012] function to produce the matrix.
```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#Field's function to produce the structure matrix
factor.structure <- function(fa, cut = 0.2, decimals = 2){
	structure.matrix <- psych::fa.sort(fa$loadings %*% fa$Phi)
	structure.matrix <- data.frame(ifelse(abs(structure.matrix) < cut, "", round(structure.matrix, decimals)))
	return(structure.matrix)
	}
	
factor.structure(grmsPAF2obl, cut = 0.3)
```
Here we see some instability. Marg6 had crossloadings with two scales and "hopped" membership onto Objectification. All three Ang items are showing factor loadings on their own scale. However, Ang1 is still loading on Strong and Ang3 has some cross-loading.

### Factor Scores

Factor *scores* (PA scores) can be created for each case (row) on each factor (column). These can be used to assess the relative standing of one person on the construct/variable to another.  We can also use them in regression (in place of means or sums) when groups of predictors correlate so highly that there is multicolliearity.

Computation involves multiplying an individual's item-level response by the factor loadings we obtained through the PAF process. The results will be one score per factor for each row/case.
 
```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#in all of this, don't forget to be specifiying the datset that has the reverse-coded item replaced 
grmsPAF2obl <- psych::fa(dfGRMS, nfactors = 4, fm = "pa", rotate = "oblimin", scores = TRUE)
head(grmsPAF2obl$scores, 10) #shows us only the first 10 (of N = 2571)
dfGRMS <- cbind(dfGRMS, grmsPAF2obl$scores) #adds them to our raw dataset
```

To bring this full circle, we can see the correlation of the factor scores; the pattern maps onto what we saw previously in the correlations between factors in the oblique rotation.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
psych::corr.test(dfGRMS [c("PA1", "PA2", "PA3", "PA4")])
```

We can extract the factor loadings and write them to a table. This can be useful in preparing an APA style table for a manuscript or presentation.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#names(grmsPAF2obl)
pafOBL_table <- round(grmsPAF2obl$loadings,3)
write.table(pafOBL_table, file="pafOBL_table.csv", sep=",", col.names=TRUE, row.names=FALSE)
pafOBL_table
```

We can also obtain a figure of this PAF with oblique rotation.
```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
psych::fa.diagram(grmsPAF2obl)
```

## APA Style Results

**Results**

>The dimensionality of the 25 items from the Gendered Racial Microagressions Scale for Black Women was analyzed using principal axis factoring. First, data screening were conducted to determine the suitability of the data for this analyses. The Kaiser-Meyer-Olkin measure of sampling adequacy (KMO; Kaiser, 1970) represents the ratio of the squared correlation between variables to the squared partial correlation between variables. KMO ranges from 0.00 to 1.00; values closer to 1.00 indicate that the patterns of correlations are relatively compact and that factor analysis should yield distinct and reliable factors (Field, 2012). In our dataset, the KMO value was .85, indicating acceptable sampling adequacy. The Barlett’s Test of Sphericity examines whether the population correlation matrix resembles an identity matrix (Field, 2012). When the *p* value for the Bartlett’s test is < .05, we are fairly certain we have clusters of correlated variables. In our dataset, $\chi^{2}(300)=1217.508, p < .001$, indicating the correlations between items are sufficiently large enough for principal factor analysis.  The determinant of the correlation matrix alerts us to any issues of multicollinearity or singularity and should be larger than 0.00001. Our determinant was 0.0075, supporting the suitability of our data for analysis.

>Four criteria were used to determine the number of factors to rotate: a priori theory, the scree test, the Eigenvalue-greater-than-one criteria, and the interpretability of the solution. Kaiser's eigenvalue-greater-than-one criteria suggested two factors, and, in combination explained 28% of the variance. The scree plot was showed an inflexion that would justified retaining between one and four factors. A priori theory based on Lewis and Neville's [-@lewis_construction_2015] psychometric evaluation, suggested four factors. Based on the convergence of these decisions, four factors were extracted.  We investigated each with orthogonal (varimax) and oblique (oblimin) procedures. Given the correspondence of the orthogonal solution with the original research, we selected this as our final model.

>The rotated solution, as shown in Table 1 and Figure 1, yielded four interpretable factors, each listed with the proportion of variance accounted for: assumptions of beauty and sexual objectification (10%), silenced and marginalized (9%), strong woman stereotype (6%), and angry woman stereotype (3%). 

Regarding the Table 1, I would include a table with all the values, bolding those with factor membership. This will be easy because we exported all those values to a .csv file. 
  
### Comparing FA and PCA

* FA derives a mathematical solution from which factors are estimated.
  + Only FA can estimate underlying factors, but it relies on the various assumptions to be met.
* PCA decomposes the original data into a set of linear variates.
  + This limits its concern to establishing which linear components exist within the data and how a particular variable might contribute to that component.
  
* Generally, FA and PCA result in similar solutions.
  + When there are 30 or more variables and communalities are > .7 for all variables, different solutions are unlikely (Stevens, 2002).
  + When there are < 20 variables and low communalities (< .4) different solutions are likely to emerge.
  + Both are inferential statistics.

* Critics of PCA suggest
  + "At best it is a common factor analysis with some error added and at worst an unrecognizable hodgepodge of things from which nothing can be determined" (Cliff, 1987, p. 349).
  + PCA should never be described as FA and the resulting components should not be treated as reverently as true, latent variable, *factors*.
  + To most of us (i.e., scientist-practitioners), the difference is largely from the algorithm used to derive the solutions.  This is true for Field [@field_discovering_2012] also, who uses the terms interchangeably.  My take:  use whichever you like, just be precise in the language describing what you did.
  
## Going Back to the Future:  What, then, is Omega?

Now that we've had an introduction to factor analysis, let's revisit the $\omega$ grouping of reliability estimates.  In the context of *psychometrics*, it may be useful to think of factors as scales/subscales where *g* refers to the amount of variance in the *general* factor (or total scale score) and subcales to be items that have something in common that is separate from what is *g*.

Model-based estimates examine the correlations or covariances of the items and decompose the test variance into that which is: 

* common to all items (**g**, a general factor), 
* specific to some items (**f**, orthogonal group factors), and 
* unique to each item (confounding **s** specific, and **e** error variance)

In the *psych* package

* $\omega_{t}$ represents the total reliability of the test ($\omega_{t}$).
  + In the *psych* package, this is calculated from a bifactor model where there is one general *g* factor (i.e., each item loads on the single general factor), one or more group factors (*f*), and an item-specific factor (*s*).
* $\omega_{h}$ extracts a higher order factor from the correlation matrix of lower level factors, then applies the Schmid and Leiman (1957) transformation to find the general loadings on the original items. Stated another way, it is a measure o f the general factor saturation (*g*; the amount of variance attributable to one comon factor). The subscript "h" acknowledges the hierarchical nature of the approach.
  +  the $\omega_{h}$ approach is exploratory and defined if there are three or more group factors (with only two group factors, the default is to assume they are equally important, hence the factor loadings of those subscales will be equal)
  + Najera Catalan [@najera_catalan_reliability_2019] suggests that $\omega_{h}$ is the best measure of reliability when dealing with multiple dimensions.
* $\omega_{g}$ is an estimate that uses a bifactor solution via the SEM package *lavaan* and tends to be a larger (because it forces all the cross loadings of lower level factors to be 0)
  + $\omega_{g}$ is confirmatory, requiring the specification of which variables load on each group factor
* *psych::omegaSem()* reports both EFA and CFA solutions
  - We will use the *psych::omegaSem()* function.

Note that in our specification, we indicate there are two factors. We do not tell it (anywhere!) what items belong to what factors (think, *subscales*). One test will be to see if the items align with their respective factors.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
#Because we added the factor scores to our df (and now it has more variables than just our items), I will estimate omegaSem with the correlation matrix; I will need to tell it the n.obs

psych::omegaSem(GRMSr, nfactors = 4, n.obs=259)
```


There's a ton of output!  How do we make sense of it?

First, excepting for the Angry scale (noted before), our items aligned reasonably with their respective factors (subscales). 

Second, we can interpret our results. Like alpha, the omegas range from 0 to 1, where values closer to 1 represent good reliability [@najera_catalan_reliability_2019]. For unidimensional measures, $\omega_{t}$ values above 0.80 seem to be an indicator of good reliability.  For multidimensional measures with well-defined dimensions we strive for $\omega_{h}$ values above 0.65 (and $\omega_{t}$ > 0.8). These recommendations are based on a Monte Carlo study that examined a host of reliability indicators and how their values corresponded with accurate predictions of poverty status. With this in mind, let's examine the output related to our simulated research vignette.

Let's examine the output in the lower portion where the values are "from a confirmatory model using sem."

Omega is a reliability estimate for factor analysis that represents the proportion of variance in the GRMS scale attributable to common variance (rather than error). The omega for the total reliability of the test ($\omega_{t}$; which included the general factors and the subscale factors) was .86, meaning that 86% of the variance in the total scale is due to the factors and 14% (100% - 86%) is attributable to error. 

Omega hierarchical ($\omega_{h}$) estimates are the proportion of variance in the GRMS score attributable to the general factor, which in effect treats the subscales as error.  $\omega_{h}$ for the the GRMS total scale was .70 A quick calculation with $\omega_{h}$ (.70) and $\omega_{t}$ (.86; .70/.86 = .81) lets us know that that 81% of the reliable variance in the GRMS total scale is attributable to the general factor. 

```{r}
.70/.86
```

Amongst the output is the Cronbach's alpha coefficient (.84). Lewis and Neville [-@lewis_construction_2015] did not report omega results. They reported an alpha of .92 for the version of the GRMS that assessed stress appraisal. 

## Comparing PFA to Item Analysis and PCA

In the lesson on PCA, we began a table that compared our item analysis (item corrected-total correlations with item-other scale correlations) and PCA results (both orthogonal and oblique). Let's now add our PAF results (both orthogonal and oblique).

In the prior lecture, I saved the file as both .rds and .csv objects. I will bring back in the .rds object and add to it.

```{r tidy=TRUE, tidy.opts=list(width.cutoff=70)}
GRMScomps <- readRDS("GRMS_Comparisons.rds")
grmsPAF2ORTH
#names(grmsPAF2ORTH)
#I had to add "unclass" to the loadings to render them into a df
pafORTH_loadings <- data.frame(unclass(grmsPAF2ORTH$loadings))
pafORTH_loadings$Items <- c("Obj1", "Obj2", "Obj3", "Obj4", "Obj5", "Obj6", "Obj7", "Obj8", "Obj9", "Obj10","Marg1", "Marg2", "Marg3", "Marg4", "Marg5", "Marg6", "Marg7", "Strong1", "Strong2", "Strong3", "Strong4", "Strong5", "Angry1", "Angry2", "Angry3") #Item names for joining (and to make sure we know which variable is which)
pafORTH_loadings <- dplyr::rename (pafORTH_loadings, PAF_OR_Obj = PA1, PAF_OR_Mar = PA2, PAF_OR_Str = PA3, PAF_OR_Ang = PA4)
#I had to add "unclass" to the loadings to render them into a df
GRMScomps <- dplyr::full_join(GRMScomps, pafORTH_loadings, by = "Items")

#Now adding the PAF oblique loadings
pafOBLQ_loadings <- data.frame(unclass(grmsPAF2obl$loadings))#I had to add "unclass" to the loadings to render them into a df
pafOBLQ_loadings$Items <- c("Obj1", "Obj2", "Obj3", "Obj4", "Obj5", "Obj6", "Obj7", "Obj8", "Obj9", "Obj10","Marg1", "Marg2", "Marg3", "Marg4", "Marg5", "Marg6", "Marg7", "Strong1", "Strong2", "Strong3", "Strong4", "Strong5", "Angry1", "Angry2", "Angry3") 

#Item names for joining (and to make sure we know which variable is which)
pafOBLQ_loadings <- dplyr::rename (pafOBLQ_loadings, PAF_OB_Obj = PA1, PAF_OB_Mar = PA2, PAF_OB_Str = PA3,  PAF_OB_Ang = PA4)

#I had to add "unclass" to the loadings to render them into a df
GRMScomps <- dplyr::full_join(GRMScomps, pafOBLQ_loadings, by = "Items")

#Writes the table to a .csv file where you can open it with Excel and format )
write.csv(GRMScomps, file = "GRMS_Comps.csv", sep = ",", row.names=FALSE, col.names=TRUE)
```

Below we can see the consistency across item analysis, PCA (orthogonal and oblique), and PAF (orthogonal and oblique) comparisons. The results were consistent across the analyses, pointing only to problems with the Angry scale. Please note that the problems were with my simulated data and not the original data.

![Comparison of path models for PCA and EFA](images/PAF/GRMScomps.png)

## Practice Problems

In each of these lessons I provide suggestions for practice that allow you to select one or more problems that are graded in difficulty. In psychometrics, I strongly recommend that you have started with a dataset that has a minimum of three subscales and use it for all of the assignments in the OER. In any case, please plan to:

* Properly format and prepare the data.
* Conduct diagnostic tests to determine the suitability of the data for PAF
* Conduct tests to guide the decisions about number of factors to extract.
* Conduct orthogonal and oblique rotations (at least two each with different numbers of factor).
* Select one solution and preparing an APA style results section (with table and figure).
* Compare your results in light of any other psychometrics lessons where you have used this data (especially the [item analysis](#ItemAnalSurvey) and [PCA](#PCA) lessons).

### Problem #1:  Play around with this simulation.

Copy the script for the simulation and then change (at least) one thing in the simulation to see how it impacts the results.  If PAF is new to you, perhaps you just change the number in "set.seed(240311)" from 240311 to something else. Your results should *parallel* those obtained in the lecture, making it easier for you to check your work as you go. Don't be surprised if the factor loadings wiggle around a little. Do try to make sense of them.


### Problem #2:  Conduct a PAF with another simulated set of data in the OER.

The second option involves utilizing one of the simulated datasets available in this OER. The [last lesson](#sims) in the OER contains three simulations that could be used for all of the statistics-based practice suggestions. Especially if you started with one of these examples in an earlier lesson, I highly recommend you continue with that.

Alternatively, Keum et al.'s Gendered Racial Microaggressions Scale for Asian American Women [@keum_gendered_2018] will be used in the lessons on confirmatory factor analysis and Conover et al.'s [@conover_development_2017] Ableist Microaggressions Scale  is used in the lesson on invariance testing. Both of these would be suitable for the PCA and PAF homework assignments.


### Problem #3:  Try something entirely new.

Using data for which you have permission and access (e.g.,  IRB approved data you have collected or from your lab; data you simulate from a published article; data from the ReCentering Psych Stats survey described in the [Qualtrics lesson](#qualTRIXdata), or data from an open science repository), complete a PAF analysis. The data should allow for at least three factors/subscales.

### Grading Rubric

Using the lecture and workflow (chart) as a guide, please work through all the steps listed in the proposed assignment/grading rubric.

|Assignment Component                    | Points Possible   | Points Earned|
|:-------------------------------------- |:----------------: |:------------:|
|1. Check and, if needed, format data    |      5            |_____  |           
|2. Conduct and interpret the three diagnostic tests to determine if PAF is appropriate as an analysis (KMO, Bartlett's, determinant).                |      5            |_____  |  
|3. Determine how many factors to extract (e.g., scree plot, eigenvalues, theory). |5  |_____  | 
|4. Conduct an orthogonal rotation with a minimum of two different numbers of factor extractions. |5        |_____  |
|5. Conduct an oblique rotation with a minimum of two different numbers of factor extractions. |5           |_____  |  
|6. Determine which factor solution (e.g., orthogonal or oblique; which number of factors) you will suggest. | 5 |_____  |               
|7. APA style results section with table and figure of one of the solutions.|    5        |_____  |   
|8. Explanation to grader                 |    5        |_____  |       
|**Totals**                               |    40       |_____  |  

```{r, child= 'Worked_Examples/5-woRked_PAF.Rmd'}
```

```{r include=FALSE}
sessionInfo()
```
