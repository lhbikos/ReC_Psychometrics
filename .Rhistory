"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
m1_indicator_push <- c(sBl = 2.5, #pushing the 1-item indicators only a little way away
tBI = 2.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
m1_indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
msmtplot1 <- semptools::set_sem_layout(plot_m1,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
plot(msmtplot1)
#changing node labels
msmtplot1b <- semptools::change_node_label(msmtplot1,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(msmtplot1b)
19*(19+1)/2
190-41
struct1 <- '
#latent variable definitions for the factors with 3 or more indicators
Climate =~ rBlst_1 + Blst_4 + Blst_6 + Blst_2 + Blst_3 + Blst_5
CourseEval =~ cEval_8 + cEval_9 + cEval_10 + cEval_11 + cEval_12 + cEval_13 + cEval_14 + cEval_15 + cEval_20 + cEval_16 + cEval_17
#latent variable definitions for the factors with 1 indicator; we set variance of the observed variable to be 0.00; this says that the LV will account for all of the variance in the observed variable
tBIPOC =~ iBIPOC_pr #for the factor "t" is teacher; for variable "i" is instructor
sBlack =~ cmBlack #for factor "s" is student; for variable "cm" is classmates
iBIPOC_pr ~~ 0*iBIPOC_pr #this specifies the error variance of the single observed variable to be 0.00
cmBlack ~~ 0*cmBlack
#structural paths
Climate ~ b*CourseEval + c_p1*tBIPOC + c_p2*sBlack
CourseEval ~ a1*tBIPOC + a2*sBlack
#script that produces information about indirect, direct, and total effects
indirect1 := a1 * b
indirect2 := a2 * b
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c := c_p1 + c_p2 + (indirect1) + (indirect2)
direct1 := c_p1
direct2 := c_p2
'
#note change in script from cfa to sem
struct1_fit <- lavaan::sem(struct1, data = Model_df, missing = 'fiml', orthogonal = TRUE)
s1fitsum<-lavaan::summary(struct1_fit, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)
s1fitsum
p <- semPlot::semPaths (struct1_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
p <- semPlot::semPaths (struct1_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
p <- semPlot::semPaths (struct1_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#I used this code to get a plot without the results printed on the paths
#p <- semPlot::semPaths (struct1_fit, what = "mod", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m_sem <- semptools::layout_matrix(sBl = c(1,1),
tBI = c(3,1),
CrE = c(2,2),
Clm = c(2,3))
#m_sem #check to see if they are where you thougth they would be; NA will be used as placeholders
#tell where you want the indicators to face
point_to <- semptools::layout_matrix (left = c(1,1),
left = c(3,1),
down = c(2,2),
right = c(2,3))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
indicator_order <- c("cmB",
"iBI",
"cE_8","cE_9","cE_10","cE_11","cE_12","cE_13","cE_14","cE_15","cE_2","cE_16","cE_17",
"rB_", "B_4", "B_6", "B_2", "B_3", "B_5")
indicator_factor <- c("sBl",
"tBI",
"CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE",
"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
indicator_push <- c(sBl = 1.5, #pushing the 1-item indicators only a little way away
tBI = 1.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
p2 <- semptools::set_sem_layout(p,
indicator_order = indicator_order,
indicator_factor = indicator_factor,
factor_layout = m_sem,
factor_point_to = point_to,
indicator_push = indicator_push,
indicator_spread = indicator_spread)
plot(p2)
#changing node labels
p3 <- semptools::change_node_label(p2,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(p3)
19*(19+1)/2
17 + 5 + 17 + 2
190-37
190-41
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = NA) #keeps out the hashtags in the knits
options(scipen=999)#eliminates scientific notation
#will install the package if not already installed
#if(!require(psych)){install.packages("psych")}
#if(!require(lavaan)){install.packages("lavaan")}
#if(!require(semPlot)){install.packages("semPlot")}
#if(!require(psych)){install.packages("psych")}
#if(!require(semTable)){install.packages("semTable")}
#if(!require(semTools)){install.packages("semTools")}
#if(!require(semptools)){install.packages("semptools")}
#The hashtagged line of code makes the connection to the institution's Qualtrics account and the individual Qualtrics account within that institutional brand. Once that connection is made, hashtag it out to avoid glitches. If you are changing from one account to another you will likely need to restart R.
#qualtRics::qualtrics_api_credentials(api_key = "mUgPMySYkiWpMFkwHale1QE5HNmh5LRUaA8d9PDg",
#base_url = "spupsych.az1.qualtrics.com", overwrite = TRUE, install = TRUE)
#surveys <- qualtRics::all_surveys()
#QTRX_df <-qualtRics::fetch_survey(surveyID = "SV_b2cClqAlLGQ6nLU", time_zone = NULL, verbose = FALSE, label=TRUE, force_request = TRUE, import_id = FALSE)
#convert=FALSE,
#eliminating previews
#QTRX_df <- dplyr::filter (QTRX_df, DistributionChannel != "preview")
#renaming variables that start with numbers
#QTRX_df <- dplyr::rename(QTRX_df, iRace1 = '1_iRace', iRace2 = '2_iRace', iRace3 = '3_iRace', iRace4 = '4_iRace', iRace5 = '5_iRace', iRace6 = '6_iRace', iRace7 = '7_iRace', iRace8 = '8_iRace', iRace9 = '9_iRace', iRace10 = '10_iRace')
#renaming variables about classmates race/ethnicity
#QTRX_df <- dplyr::rename(QTRX_df, cmBiMulti = Race_10, cmBlack = Race_1, cmNBPoC = Race_7, cmWhite = Race_8, cmUnsure = Race_2)
library(tidyverse)#opening this package to be able to use pipes
#creating ID variable and moving it to the front
#QTRX_df <- QTRX_df %>% dplyr::mutate(ID = row_number())
#QTRX_df <- QTRX_df%>%dplyr::select(ID, everything())
#downsizing df to have just variables of interest
#Model_df <-(select (QTRX_df, ID, iRace1, iRace2, iRace3, iRace4, iRace5, iRace6, iRace7, iRace8, iRace9, iRace10, cmBiMulti, cmBlack, cmNBPoC, cmWhite, cmUnsure, Blst_1:Blst_6, cEval_8, cEval_9, cEval_10, cEval_11, cEval_12, cEval_13, cEval_14, cEval_15, cEval_20, cEval_16,cEval_17))
#write the simulated data  as a .csv
#write.table(Model_df, file="Model_df.csv", sep=",", col.names=TRUE, row.names=FALSE)
#bring back the simulated dat from a .csv file
#Model_df <- read.csv ("Model_df.csv", header = TRUE)
#to save the df as an .rds (think "R object") file on your computer; it should save in the same file as the .rmd file you are working with
#saveRDS(Model_df, "Model_df.rds")
#bring back the simulated dat from an .rds file
Model_df <- readRDS("Model_df211010.rds") #For this lesson, I saved and imported this set of data; use it if you want the same results as are in the lesson and screencasted lecture
#Model_df <- readRDS("Model_df.rds")
#str(Model_df$iRace1)
Model_df$tRace1 = factor(Model_df$iRace1,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace2 = factor(Model_df$iRace2,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace3 = factor(Model_df$iRace3,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace4 = factor(Model_df$iRace4,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace5 = factor(Model_df$iRace5,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace6 = factor(Model_df$iRace6,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace7 = factor(Model_df$iRace7,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace8 = factor(Model_df$iRace8,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace9 = factor(Model_df$iRace9,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
Model_df$tRace10 = factor(Model_df$iRace10,
levels = c(0,1,2,3,4),
labels = c("Black", "nBpoc", "BiMulti", "White", "NotNotice"))
#checking to see that they are factors
#glimpse(Model_df)
#counting non-White instructional staff by creating the variable "count.BIPOC" by
#summing across tRace1 thru tRace10 and assigning a count of "1" each time the factor value was Black, nBpoc, or BiMulti
Model_df$count.BIPOC <- apply(Model_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(x %in% c("Black", "nBpoc", "BiMulti")))
#created a variable that counted the number of non-missing values across the tRace1 thru tRace10 vars
Model_df$count.nMiss <- apply(Model_df[c("tRace1", "tRace2", "tRace3", "tRace4", "tRace5", "tRace6", "tRace7", "tRace8", "tRace9", "tRace10")], 1, function(x) sum(!is.na(x)))
#calculate proportion of BIPOC instructional faculty for each case
Model_df$iBIPOC_pr = Model_df$count.BIPOC/Model_df$count.nMiss
library(tidyverse)
Model_df<- Model_df %>%
dplyr::mutate(rBlst_1 = 8 - Blst_1) #if you had multiple items, you could add a pipe (%>%) at the end of the line and add more until the last one
#selecting the variables we want
Model_df <-dplyr::select(Model_df, ID, iBIPOC_pr, cmBlack, rBlst_1, Blst_2:Blst_6, cEval_8:cEval_17)
cases1 <- nrow(Model_df) #I produced this object for the sole purpose of feeding the number of cases into the inline text, below
cases1
library(tidyverse)
#Create a variable (n_miss) that counts the number missing
Model_df$n_miss <- Model_df%>%
dplyr::select(iBIPOC_pr:cEval_17) %>%
is.na %>%
rowSums
#Create a proportion missing by dividing n_miss by the total number of variables (21)
#Sort in order of descending frequency to get a sense of the missingness
Model_df<- Model_df%>%
dplyr::mutate(prop_miss = (n_miss/21)*100)%>%
arrange(desc(n_miss))
PrMiss1 <- psych::describe(Model_df$prop_miss)
PrMiss1
MissMin1 <- formattable::digits(PrMiss1$min, 0)#this object is displayed below and I use input from  it for the inline text used in the write-up
MissMax1 <- formattable::digits(PrMiss1$max, 0)
MissMin1
MissMax1
CellsMissing1 <-formattable::percent(mean(is.na(Model_df))) #percent missing across df
RowsMissing1 <- formattable::percent(mean(complete.cases(Model_df))) #percent of rows with nonmissing data
CellsMissing1
RowsMissing1
missingness <- mice::md.pattern(Model_df, plot = TRUE, rotate.names=TRUE)
missingness
Model_df <- filter(Model_df, prop_miss <= 20)  #update df to have only those with at least 20% of complete data (this is an arbitrary decision)
Model_df <-dplyr::select (Model_df, iBIPOC_pr:cEval_17) #the variable selection just lops off the proportion missing
CasesIncluded <- nrow(Model_df)
CasesIncluded #this object is displayed below and I use input from  it for the inline text used in the write-up
CellsMissing2 <- formattable::percent(mean(is.na(Model_df))) #percent missing across df
RowsMissing2 <- formattable::percent(mean(complete.cases(Model_df))) #percent of rows with nonmissing data
CellsMissing2
RowsMissing2
missingness2 <- mice::md.pattern(Model_df, plot = TRUE, rotate.names=TRUE)
missingness2
psych::describe(Model_df)
Model_df$Mahal <- psych::outlier(Model_df)
library(dplyr)
#str(item_scores_df$Mahal)
Model_df$MOutlier <- if_else(Model_df$Mahal > (median(Model_df$Mahal) + (3*sd(Model_df$Mahal))), TRUE, FALSE)
OutlierCount <- Model_df%>%
count(MOutlier)
OutlierCount
NumOutliers <- nrow(Model_df) - OutlierCount #calculating how many outliers
NumOutliers #this object is used for the inline text for the reesults
NumOutliers
head(Model_df) #shows us the first 6 rows of the data so we can see the new variables (Mahal, MOutlier)
ClimateItems <- dplyr::select(Model_df, rBlst_1, Blst_2, Blst_3, Blst_4, Blst_5, Blst_6)
CEvalItems <- dplyr::select(Model_df, cEval_8, cEval_9, cEval_10, cEval_11, cEval_12, cEval_13, cEval_14, cEval_15, cEval_16, cEval_17, cEval_20)
ClimateAlpha <- psych::alpha(ClimateItems)
ClimateAlpha
CEvalAlpha <- psych::alpha(CEvalItems)
CEvalAlpha
#create lists of the items
ClimateVars <- c('rBlst_1', 'Blst_2', 'Blst_3', 'Blst_4', 'Blst_5', 'Blst_6')
CEvalVars <- c('cEval_8', 'cEval_9', 'cEval_10', 'cEval_11', 'cEval_12', 'cEval_13', 'cEval_14', 'cEval_15', 'cEval_16', 'cEval_17', 'cEval_20')
#calculate means for when a specified proportion of items are non-missing
Model_df$ClimateM <- sjstats::mean_n(Model_df[,ClimateVars], .80)#will create the mean for each individual if 80% of variables are present (this means there must be at least 5 of 6)
Model_df$CEvalM <- sjstats::mean_n(Model_df[,CEvalVars], .80)#will create the mean for each individual if 80% of variables are present (this means there must be at least 9 of 11)
apaTables::apa.cor.table(Model_df[c('ClimateM', 'CEvalM', 'iBIPOC_pr', 'cmBlack')], landscape=TRUE, table.number = 1, filename="Table1_Prelim.doc")
msmt <- '
#latent variable definitions for the factors with 3 or more indicators
Climate =~ rBlst_1 + Blst_4 + Blst_6 + Blst_2 + Blst_3 + Blst_5
CourseEval =~ cEval_8 + cEval_9 + cEval_10 + cEval_11 + cEval_12 + cEval_13 + cEval_14 + cEval_15 + cEval_20 + cEval_16 + cEval_17
#latent variable definitions for the factors with 1 indicator; we set variance of the observed variable to be 0.00; this says that the LV will account for all of the variance in the observed variable
tBIPOC =~ iBIPOC_pr #for the factor "t" is teacher; for variable "i" is instructor
sBlack =~ cmBlack #for factor "s" is student; for variable "cm" is classmates
iBIPOC_pr ~~ 0*iBIPOC_pr #this specifies the error variance of the single observed variable to be 0.00
cmBlack ~~ 0*cmBlack
'
msmt_fit <- lavaan::cfa(msmt, data = Model_df, missing = "fiml", check.gradient=FALSE)
#msmt_fit <- lavaan::cfa(msmt, data = Model_df,  missing = "fiml", estimator = "ML", bounds = "wide")
m1fitsum <- lavaan::summary(msmt_fit, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)
#missing = 'fiml',
m1fitsum
plot_m1 <- semPlot::semPaths(msmt_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m1_msmt <- semptools::layout_matrix(sBl = c(1,1),
tBI = c(2,1),
CrE = c(1,2),
Clm = c(2,2))
#m_msmt #can check to see if it is what you thought you did
#tell where you want the indicators to face
m1_point_to <- semptools::layout_matrix (left = c(1,1),
left = c(2,1),
up = c(1,2),
down = c(2,2))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
m1_indicator_order <- c("cmB",
"iBI",
"cE_8","cE_9","cE_10","cE_11","cE_12","cE_13","cE_14","cE_15","cE_2","cE_16","cE_17",
"rB_", "B_4", "B_6", "B_2", "B_3", "B_5")
m1_indicator_factor <- c("sBl",
"tBI",
"CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE","CrE",
"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
m1_indicator_push <- c(sBl = 2.5, #pushing the 1-item indicators only a little way away
tBI = 2.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
m1_indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
msmtplot1 <- semptools::set_sem_layout(plot_m1,
indicator_order = m1_indicator_order,
indicator_factor = m1_indicator_factor,
factor_layout = m1_msmt,
factor_point_to = m1_point_to,
indicator_push = m1_indicator_push,
indicator_spread = m1_indicator_spread)
plot(msmtplot1)
#changing node labels
msmtplot1b <- semptools::change_node_label(msmtplot1,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(msmtplot1b)
19*(19+1)/2
17 + 5 + 17 + 2
190-41
struct1 <- '
#latent variable definitions for the factors with 3 or more indicators
Climate =~ rBlst_1 + Blst_4 + Blst_6 + Blst_2 + Blst_3 + Blst_5
CourseEval =~ cEval_8 + cEval_9 + cEval_10 + cEval_11 + cEval_12 + cEval_13 + cEval_14 + cEval_15 + cEval_20 + cEval_16 + cEval_17
#latent variable definitions for the factors with 1 indicator; we set variance of the observed variable to be 0.00; this says that the LV will account for all of the variance in the observed variable
tBIPOC =~ iBIPOC_pr #for the factor "t" is teacher; for variable "i" is instructor
sBlack =~ cmBlack #for factor "s" is student; for variable "cm" is classmates
iBIPOC_pr ~~ 0*iBIPOC_pr #this specifies the error variance of the single observed variable to be 0.00
cmBlack ~~ 0*cmBlack
#structural paths
Climate ~ b*CourseEval + c_p1*tBIPOC + c_p2*sBlack
CourseEval ~ a1*tBIPOC + a2*sBlack
#script that produces information about indirect, direct, and total effects
indirect1 := a1 * b
indirect2 := a2 * b
contrast := indirect1 - indirect2
total_indirects := indirect1 + indirect2
total_c := c_p1 + c_p2 + (indirect1) + (indirect2)
direct1 := c_p1
direct2 := c_p2
'
#note change in script from cfa to sem
struct1_fit <- lavaan::sem(struct1, data = Model_df, missing = 'fiml', orthogonal = TRUE)
s1fitsum<-lavaan::summary(struct1_fit, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)
s1fitsum
p <- semPlot::semPaths (struct1_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
p
p <- semPlot::semPaths (struct1_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
p <- semPlot::semPaths (struct1_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#I used this code to get a plot without the results printed on the paths
#p <- semPlot::semPaths (struct1_fit, what = "mod", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
#IMPORTANT:  Must use the node names (take directly from the SemPlot) assigned by SemPlot
#You can change them as the last thing
m_sem <- semptools::layout_matrix(sBl = c(1,1),
tBI = c(3,1),
CrE = c(2,2),
Clm = c(2,3))
#m_sem #check to see if they are where you thougth they would be; NA will be used as placeholders
#tell where you want the indicators to face
point_to <- semptools::layout_matrix (left = c(1,1),
left = c(3,1),
down = c(2,2),
right = c(2,3))
#the next two codes -- indicator_order and indicator_factor are paired together, they specify the order of observed variables for each factor
indicator_order <- c("cmB",
"iBI",
"cE_8","cE_9","cE_10","cE_11","cE_12","cE_13","cE_14","cE_15","cE_2","cE_16","cE_17",
"rB_", "B_4", "B_6", "B_2", "B_3", "B_5")
indicator_factor <- c("sBl",
"tBI",
"CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE", "CrE",
"Clm", "Clm", "Clm", "Clm", "Clm", "Clm")
#next set of code pushes the indicator variables away from the factor
indicator_push <- c(sBl = 1.5, #pushing the 1-item indicators only a little way away
tBI = 1.5,
CrE = 2,5, #pushing the multi-item indicators further away)
Clm = 2.5)
indicator_spread <- c(CrE = 2, #spreading the boxes away from each other
Clm = 2)
p2 <- semptools::set_sem_layout(p,
indicator_order = indicator_order,
indicator_factor = indicator_factor,
factor_layout = m_sem,
factor_point_to = point_to,
indicator_push = indicator_push,
indicator_spread = indicator_spread)
plot(p2)
#changing node labels
p3 <- semptools::change_node_label(p2,
c(sBl = "stntBlack",
tBI = "tchBIPOC",
CrE = "Evals",
Clm = "Climate"),
label.cex = 1.1)
plot(p3)
raw <- readRDS("ReC.rds")
View(raw)
View(raw)
raw <-(dplyr::filter(raw, Course == "Psychometrics"))
View(raw)
babydf <- dplyr::select(raw, Centering, ClearResponsibilities, EffectiveAnswers, Feedback, ClearOrganization, ClearPresentation, ValObjectives, IncrUnderstanding, IncrInterest, InclusvClassrm, EquitableEval, MultPerspectives, DEIintegration)
str(babydf)
babydf$CEN <- as.numeric(babydf$Centering)
babydf$CEN <- (babydf$CEN - 1)
str(babydf)
babydf$CEN <- as.numeric(babydf$Centering)
babydf$CEN <- (babydf$CEN - 1)
str(babydf)
View(babydf)
cases1 <- nrow(babydf) #I produced this object for the sole purpose of feeding the number of cases into the inline text, below
cases1
library(tidyverse)
#Create a variable (n_miss) that counts the number missing
babydf$n_miss <- babydf%>%
dplyr::select(Centering:DEIintegration) %>%
is.na %>%
rowSums
View(babydf)
#Create a proportion missing by dividing n_miss by the total number of variables (21)
#Sort in order of descending frequency to get a sense of the missingness
babydf<- babydf%>%
dplyr::mutate(prop_miss = (n_miss/13)*100)%>%
arrange(desc(n_miss))
CellsMissing1 <-formattable::percent(mean(is.na(babydf))) #percent missing across df
RowsMissing1 <- formattable::percent(mean(complete.cases(babydf))) #percent of rows with non-missing data
CellsMissing1
RowsMissing1
missingness <- mice::md.pattern(babydf, plot = TRUE, rotate.names=TRUE)
missingness
psych::describe(babydf)
Mahal_df <- dplyr::select(babydf, ClearResponsibilities, EffectiveAnswers, Feedback, ClearOrganization, ClearPresentation, ValObjectives, IncrUnderstanding, IncrInterest, InclusvClassrm, EquitableEval, MultPerspectives, DEIintegration)
Mahal_df$Mahal <- psych::outlier(Mahal_df)
View(babydf)
View(Mahal_df)
library(dplyr)
#str(item_scores_df$Mahal)
Mahal_df$MOutlier <- if_else(Mahal_df$Mahal > (median(Mahal_df$Mahal) + (3*sd(Mahal_df$Mahal))), TRUE, FALSE)
head(Mahal_df) #shows us the first 6 rows of the data so we can see the new variables (Mahal, MOutlier)
OutlierCount <- Mahal_df%>%
count(MOutlier)
OutlierCount
OutlierCount <- Mahal_df%>%
count(MOutlier)
OutlierCount
ValuedVars <- c("ValObjectives", "IncrUnderstanding", "IncrInterest")
TradPedVars <- c("ClearResponsibilities", "EffectiveAnswers", "Feedback", "ClearOrganization", "ClearPresentation")
SRPedVars <- c("InclusvClassrm", "EquitableEval", "MultPerspectives", "DEIintegration")
psych::alpha(babydf[, ..ValuedVars])
#if this code throws an error for you rewrite deleting the two dots in front of the ValuedVars object
psych::alpha(babydf[, ..TradPedVars])
psych::alpha(babydf[, ..SRPedVars])
#calculate means for when a specified proportion of items are non-missing
babydf$Valued <- sjstats::mean_n(babydf[,..ValuedVars], .66)#will create the mean for each individual if 66% of variables are non-missing
babydf$TradPed <- sjstats::mean_n(babydf[, ..TradPedVars], .66)#will create the mean for each individual if 66% of variables are non-missing
babydf$SRPed <- sjstats::mean_n(babydf[, ..SRPedVars], .66)#will create the mean for each individual if 66% of variables are non-missing
corr_df <- dplyr::select(babydf, Valued, TradPed, SRPed, CEN)
apaTables::apa.cor.table(corr_df)
msmt_mod <- "
##measurement model
CTR =~ CEN
TrP =~ ClearResponsibilities + EffectiveAnswers + Feedback + ClearOrganization + ClearPresentation
SRP =~ InclusvClassrm + EquitableEval + MultPerspectives + DEIintegration
Val =~ ValObjectives + IncrUnderstanding + IncrInterest
# Variance of the single item indicator
CTR ~~ 0*CEN
# Covariances
CTR ~~ TrP
CTR ~~ SRP
CTR ~~ Val
TrP ~~ SRP
TrP ~~ Val
SRP ~~ Val
"
msmt_mod <- "
##measurement model
CTR =~ CEN
TrP =~ ClearResponsibilities + EffectiveAnswers + Feedback + ClearOrganization + ClearPresentation
SRP =~ InclusvClassrm + EquitableEval + MultPerspectives + DEIintegration
Val =~ ValObjectives + IncrUnderstanding + IncrInterest
# Variance of the single item indicator
CTR ~~ 0*CEN
# Covariances
CTR ~~ TrP
CTR ~~ SRP
CTR ~~ Val
TrP ~~ SRP
TrP ~~ Val
SRP ~~ Val
"
set.seed(230916)
msmt_fit <- lavaan::cfa(msmt_mod, data = babydf, missing = "fiml")
lavaan::summary(msmt_fit, fit.measures = TRUE, standardized = TRUE)
#global fit indices
msmt_globalfit <- tidySEM::table_fit(msmt_fit)
msmt_fit_pEsts <- tidySEM::table_results(msmt_fit, digits=3, columns = NULL)
write.csv(msmt_globalfit, file = "msmt_globalfit.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(msmt_fit_pEsts, file = "msmt_fit_pEsts.csv")
msmt_m1 <- semPlot::semPaths(msmt_fit, what = "col", whatLabels = "stand", sizeMan = 5, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(5,5,5,5))
ReC_struct_mod1 <- "
#measurement model
CTR =~ CEN #this is a single item indicator, I had to add code below to set the variance
TrP =~ ClearResponsibilities + EffectiveAnswers + Feedback + ClearOrganization + ClearPresentation
SRP =~ InclusvClassrm + EquitableEval + MultPerspectives + DEIintegration
Val =~ ValObjectives + IncrUnderstanding + IncrInterest
# Variance of the single item indicator
CTR ~~ 0*CEN
#structural model
Val ~ CTR + TrP + SRP
"
set.seed(230916) #needed for reproducibility
ReC_struct_fit1 <- lavaan::sem(ReC_struct_mod1, data = babydf, missing= 'fiml', fixed.x=FALSE, auto.cov.lv.x=FALSE)
lavaan::summary(ReC_struct_fit1, fit.measures=TRUE, standardized=TRUE, rsq = TRUE)
#global fit indices
ReC_globalfit1 <- tidySEM::table_fit(ReC_struct_fit1)
ReC_struct_pEsts <- tidySEM::table_results(ReC_struct_fit1, digits=3, columns = NULL)
write.csv(ReC_globalfit1, file = "ReC_globalfit1.csv")
#the code below writes the parameter estimates into a .csv file
write.csv(ReC_struct_pEsts, file = "ReC_struct_pEsts1.csv")
plot_ReC_struct1 <- semPlot::semPaths(ReC_struct_fit1, what = "col", whatLabels = "stand", sizeMan = 3, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(2,2,2,2), structural = FALSE, curve=FALSE, intercepts=FALSE, layout = "tree", rotation = 2)
plot_ReC_struct1 <- semPlot::semPaths(ReC_struct_fit1, what = "col", whatLabels = "stand", sizeMan = 3, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(2,2,2,2), structural = FALSE, curve=FALSE, intercepts=FALSE, layout = "tree")
plot_ReC_struct1 <- semPlot::semPaths(ReC_struct_fit1, what = "col", whatLabels = "stand", sizeMan = 3, node.width = 1, edge.label.cex = .75, style = "lisrel", mar = c(2,2,2,2), structural = FALSE, curve=FALSE, intercepts=FALSE, layout = "tree", rotation = 2)
